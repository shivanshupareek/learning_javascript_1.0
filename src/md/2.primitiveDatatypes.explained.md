# Explanation: src/content/2.primitiveDatatypes.js

This document explains the learning notes in src/content/2.primitiveDatatypes.js. That JS file is comment-heavy and intended for reading, not execution. Below is a structured, practical guide matching and clarifying its topics.

## 1) What are primitive data types in JavaScript?

JavaScript has seven primitive types (values are immutable and compared by value):
- string — sequence of characters. Example: "hello".
- number — double‑precision floating point numbers. Example: 10, 3.14, NaN, Infinity.
- boolean — true or false.
- bigint — integers of arbitrary size, written with an n suffix. Example: 12939n.
- undefined — the default value of an uninitialized variable.
- null — an intentional “empty” value.
- symbol — unique and immutable identifiers.

Anything else (object, array, function, date, regex, etc.) is a reference type (non‑primitive).

## 2) Primitive vs Reference (copy semantics)

- Primitive values are copied by value:
  - let a = 10; let b = a; a = a + 2; // b stays 10, a becomes 12.
- Reference values are copied by reference:
  - Two variables can point to the same object; mutating the object is observed through both variables.
  - To create a shallow copy of objects/arrays, use the spread operator or structuredClone (when appropriate).

## 3) Quotes for strings

You can write strings with:
- Single quotes: 'hello'
- Double quotes: "hello"
- Backticks (template literals): `hello` — support interpolation (e.g., `Hello, ${name}`) and multi‑line strings.

## 4) Mutable vs Immutable

- Mutable (can change): values inside objects and arrays; variables declared with let/var can be reassigned.
- Immutable (cannot change the value itself): primitive values. Reassignment creates a new value/binding.
  - const prevents reassignment of the binding, but if the binding holds an object, you can still mutate the object’s contents:
    - const person = { name: "hello" };
    - person.name = "New hello"; // allowed — object is mutable even if the binding is const
    - person = {} // not allowed — cannot reassign a const binding

## 5) null vs undefined

- undefined
  - Means “not initialized.” Local variables without an initializer start as undefined.
  - Functions with no explicit return also return undefined.
- null
  - An explicit, intentional “no value yet.” Useful as a placeholder to say, “I know about this variable; there’s just no value right now.”
- Quirk: typeof null === "object" due to a historical spec detail; treat it as a special primitive instead of an object.

Examples:
- let a; // a is undefined
- let b = null; // intentional empty value

## 6) Symbol (unique identifiers)

- Introduced in ES2015. Each Symbol() call creates a unique value.
- Symbols are often used as object keys to avoid name collisions.

Example:
```js
const id = Symbol("id");
const obj = { id: 2851720 };
obj[id] = 2851720; // different from obj.id
console.log(typeof id); // "symbol"
```

## 7) BigInt (very large integers)

- Introduced in ES2020. Use an n suffix: 123n, 9007199254740993n.
- Use BigInt for integers larger than Number.MAX_SAFE_INTEGER (9007199254740991).
- BigInt and Number do not mix in arithmetic; convert or use BigInt consistently.

Examples:
```js
const maxSafe = Number.MAX_SAFE_INTEGER; // 9007199254740991
const huge = 123456789n;
const sum = huge + 5n; // works → 123456794n
```

## 8) Boxing (temporary object wrappers)

JavaScript temporarily boxes primitives so you can call methods on them:
- "hello".toUpperCase() // works, engine treats it like new String("hello") for the call
- (33).toFixed(3) // "33.000"

Avoid using new String(), new Number(), or new Boolean(); they create objects, not primitives, and can cause confusing behavior.

## 9) Quick checks and typeof

- typeof "hi" → "string"
- typeof 10 → "number"
- typeof true → "boolean"
- typeof 123n → "bigint"
- typeof undefined → "undefined"
- typeof null → "object" // historical quirk
- typeof Symbol("x") → "symbol"

## 10) Practical tips

- Prefer const; use let only when you need to reassign. This reduces accidental mutation.
- Use template literals (backticks) for string interpolation and multi‑line strings.
- Choose null intentionally to represent “no value yet;” let undefined represent “not set by code.”
- Use Symbol keys to create non‑colliding properties on objects.
- Use BigInt only when the range of Number is insufficient; keep arithmetic types consistent.
- When copying objects/arrays (reference types), use cloning techniques (e.g., spread) if you need independence from the original.
